====================
Brainfuck 机设计方案
====================

:Author:    Weisi Dai <weisi@x-research.com>
:Date:      May 23, 2012
:Revision:  1
:Copyright: `CC BY-NC-SA 2.0 <http://creativecommons.org/licenses/by-nc-sa/2.0/>`_

设计思路
========

    * 指令简单
    * 功能强大

指令集合
--------

    ==========  ======================================= =================== =======
    助记符      含义                                    C 语言等价形式      编码
    ==========  ======================================= =================== =======
    ``>``       指针自增                                ``++P;``            ``000``
    ``<``       指针自减                                ``--P;``            ``001``
    ``+``       指针指向单元自增                        ``++*P;``           ``010``
    ``-``       指针指向单元自减                        ``--*P;``           ``011``
    ``[``       指针指向单元为零则跳转到 ``]`` 之后     ``while (*P){``     ``100``
    ``]``       跳转到对应的 ``[``                      ``}``               ``101``
    ``.``       输出指针指向单元的值                    ``putchar(*P);``    ``110``
    ``,``       读入指针指向单元的值                    ``*P = getchar();`` ``111``
    ==========  ======================================= =================== =======

数据表示
--------

    * 指令和数据分开存储和表示.

    * 指令段: 12 KB. 每条指令 3 比特, 因此可以存放 4096 条指令.

    * 数据段: 4 KB. 数据宽度为 8 位, 因此数据段包括 4096 个单元.

    * PC 的宽度为 12 位. ``P`` 指针的宽度为 12 位.

执行阶段
--------

    #. 开机, 读入程序内容.
    #. 执行程序.
    #. 停机.

外部接口
--------

    * 输入接口
        * 指令输入, 3 位.
        * 指令输入状态, 1 位. 给出指令输入时有效. 信号一旦无效则第 1 阶段结束.

        * 数据输入, 8 位.
        * 数据输入状态, 1 位. 有数据输入时有效.

    * 输出接口
        * 数据输出, 8 位.
        * 数据输出状态, 1 位, 当前有数据输出时有效.

        * 等待数据输入状态, 1 位, 等待数据输入时有效.

        * 停机状态, 1 位. 停机时有效.

程序示例
--------

    * Hello World
        ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.

      解释::

        +++++ +++++      将 0 号单元的值置为 10
        [                循环 10 次, 设置后面四个单元分别为 70, 100, 30, 10
            > +++++ ++       1 号单元加 7
            > +++++ +++++    2 号单元加 10
            > +++            3 号单元加 3
            > +              4 号单元加 1
            <<<< -           0 号单元自减
        ]                   
        > ++ .                  输出 'H'
        > + .                   输出 'e'
        +++++ ++ .              输出 'l'
        .                       输出 'l'
        +++ .                   输出 'o'
        > ++ .                  输出 ' '
        << +++++ +++++ +++++ .  输出 'W'
        > .                     输出 'o'
        +++ .                   输出 'r'
        ----- - .               输出 'l'
        ----- --- .             输出 'd'
        > + .                   输出 '!'
        > .                     输出换行符 '\n'

设计过程
========

用到的模块
----------

    * 指令存储器 Instruction Memory
    * 数据存储器 Data Memory
    * 寄存器 Registers
      包括 PC, ``P``, AX, IC (Instruction Counter)
    * 输入输出接口 I/O Interface
    * 循环辅助堆栈 Loop Stack

指令的实现
----------

    除 ``,`` 指令外, 执行一条指令需要 4 个节拍.

    * ``>`` 指针自增
        #. ``P`` 计数器自增
        #. PC 计数器自增

    * ``<`` 指针自减
        #. ``P`` 计数器自减
        #. PC 计数器自增

    * ``+`` 指针指向单元自增
        #. 从存储器中读出 ``P`` 计数器指向的单元到 AX
        #. AX 自\ **增**
        #. 将 AX 写入存储器中 ``P`` 计数器指向的单元
        #. PC 计数器自增

    * ``-`` 指针指向单元自减
        #. 从存储器中读出 ``P`` 计数器指向的单元到 AX
        #. AX 自\ **减**
        #. 将 AX 写入存储器中 ``P`` 计数器指向的单元
        #. PC 计数器自增

    * ``[`` 指针指向单元不为零则跳转到 ``]`` 之后
        #. 若 ``P`` 计数器指向的单元不为零则将 PC 压入 Loop Stack
        #. PC 计数器自增

    * ``]`` 跳转到对应的 ``[``
        #. PC 计数器自增 (思考: 为什么这里先执行?)
        #. 若 ``P`` 计数器指向的单元不为零从 Loop Stack 中弹出 PC, 否则丢弃 Loop Stack 的栈顶元素

    * ``.`` 输出指针指向单元的值
        #. 从存储器中读出 ``P`` 计数器指向的单元到 AX
        #. 输出 AX 的值, 数据输出使能
        #. PC 计数器自增

    * ``,`` 读入指针指向单元的值
        #. 等待数据输入信号使能, 等待数据输入
        #. 将数据输入到 AX, 等待数据输入信号取消使能
        #. 将 AX 写入存储器中 ``P`` 计数器指向的单元
        #. PC 计数器自增

状态的切换
----------

    * 输入指令时, 若指令输入状态无效进入执行指令阶段.
    * 单个指令执行完成后, PC 一旦超出 IC 则进入停机状态.

评估
====

    * 指令简单
        仅有 8 个指令, 易于实现.

    * 功能强大
        图灵完全.
