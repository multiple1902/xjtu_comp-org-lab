============
功能模块设计
============

:Author:    Weisi Dai <weisi@x-research.com>
:Date:      Apr 18. 2012
:Revision:  1
:Copyright: `CC BY-NC-SA 2.0 <http://creativecommons.org/licenses/by-nc-sa/2.0/>`_

运算器
======

16 位运算器。

输入和输出
----------

输入
^^^^

* 运算数1, 运算数2: 各16比特 （浮点数为IEEE 754, binary 16, 半精度浮动小数点数）
* 操作码: 4比特, 允许16种运算

输出
^^^^

* 运算结果: 16比特
* 溢出和出错标志: 1比特

指令集合的设计
--------------

算术逻辑运算
^^^^^^^^^^^^

    ======== =========
    **0000** 按位与
    **0001** 按位或
    **0010** 按位异或
    **0011** 按位非（忽略运算数 2）
    ======== =========

补码整数运算
^^^^^^^^^^^^

    ======== =========
    **0100** 补码加法
    **0101** 补码减法
    **0110** 补码乘法
    ======== =========

..
    * **0111** 补码除法

移位运算
^^^^^^^^

    ======== =========
    **1000** 逻辑左移
    **1001** 逻辑右移
    **1010** 算术左移
    **1011** 算术右移
    ======== =========

浮点运算（未完全实现）
^^^^^^^^^^^^^^^^^^^^^^

    ======== =========
    **1100** 浮点加法
    **1101** 浮点减法
    **1110** 浮点乘法
    **1111** 浮点除法
    ======== =========

工作原理
--------

运算器根据不同的指令编号，对两个操作数施加特定的运算，如算术逻辑运算（位操作）、补码整数运算、移位运算和浮点运算（未完全实现）等。

在不同运算类型下，操作数的含义不同：

* 执行\ **位操作**\ 时，操作数被认为是\ **逻辑0-1串**\ ；
* 执行\ **补码整数运算**\ 时，操作数被认为是\ **补码**\ ；
* 执行\ **算术移位运算**\ 时，操作数被认为是\ **有算术含义的0-1串**\ ；
* 执行\ **逻辑移位运算**\ 时，操作数被认为是\ **逻辑0-1串**\ ；
* 执行\ **浮点运算**\ （未完全实现）时，操作数被认为是\ **符合 IEEE 754 标准的 16 比特浮点数**\ ，即 binary16。

为实现 IEEE 754 标准中的浮点运算，设计了 binary16 模块，但未完全完成。其中设计了浮点数的\ **中间表示**\ ，以方便做各种运算。

工作步骤
--------

#. 运算器的敏感信号（操作数 1 ，操作数 2 ，运算指令）发生改变，
#. 重置出错和进位标志 exception，
#. 根据运算指令，执行不同的流程：

    * 算术逻辑运算

        * 不会出错，
        * 按位非运算中忽略操作数 2。

    * 补码整数运算

        * 相加时，出错和进位标志表示是否产生进位，
        * 运算时转换为原码，调用内部运算流程，
        * 乘法结果取最低 16 位，出错和进位标志表示是否溢出。

    * 移位运算

        * 将操作数2 作为要移的位数。

    * 浮点运算（未完全实现）

        * 调用 binary16 模块。

#. 将计算所得的结果输出。

测试用例
--------

* 传入的操作数固定，
* 按照设计的指令表分别传入不同的运算指令。


指令译码器
==========

原则上应该先设计出指令体系，然后根据具体的指令编码来设计指令译码器的输入输出关系。这里只实现了一个普通的 4-16 译码器。

输入和输出
----------

输入
^^^^

* 4 位指令编码
* 时钟信号（无实际作用）

输出
^^^^

* 16 个二进制位

工作原理
--------

敏感信号指令编码发生变化时，利用分支语句 case 执行语句，将输出设置为指定的值。

工作方式类似于「打表」。

测试用例
--------

类似「运算器」的测试用例，按照指令表传入不同的运算指令。


三级时序电路
============

由时钟信号产生 CPU 工作的 4 个阶段的控制信号。


输入和输出
----------

输入
^^^^

* 时钟信号

输出
^^^^

* 4 个阶段的控制信号

工作原理
--------

#. 利用临时变量保存内部状态，
#. 内部状态初始化为「0001」，
#. 在敏感信号发生变化时，在下降沿执行状态跳转：

    #. 将内部状态的后三位作为新状态的前三位，
    #. 将内部状态的第一位作为新状态的最后一位，
    #. 用新状态取代旧状态，
    #. 将状态传输到模块的输出端。

测试用例
--------

时钟信号在 0 和 1 两个状态中循环，在每个状态保持相等时间（10 ms）。

存储器
======

输入和输出
----------

输入
^^^^

* 片选信号
* 读有效信号，写有效信号
* 地址高 5 位，地址低 5 位
* 16 位数据输入
* 时钟信号

输出
^^^^

* 16 位数据输出

工作原理
--------

利用内置的数组功能实现数据的短时间保存。

* 敏感信号发生变化时，若时钟信号处于上升沿，并且片选信号有效：

    * 若\ **读信号**\ 有效，则根据高 5 位和低 5 位地址，组合成为 10 位的单元地址，转换为整数作为数组下标，\ **读出**\ 16 位目标数据后直接交给输出信号；

    * 否则若\ **写信号**\ 有效，则依然根据高 5 位和低 5 位地址，组合成为 10 位的单元地址，转换为整数作为数组下标，同时将 16 位目标数据\ **写入**\ 对应单元。

* 否则什么都不做。

测试用例
--------

先执行对某个单元的写入操作，随后试图读出这个单元的值。
